#category-mindmap

css:
  .node circle {
    stroke-width: 1.5px;
  }

  .node circle.visible {
    fill: #fff;
    stroke: steelblue;
  }

  .node circle.not-visible {
    fill: #eee;
    stroke: darkgrey;
  }

  .node {
    font: 10px sans-serif;
  }

  .link {
    fill: none;
    stroke: #dedede;
    stroke-width: 1.5px;
  }

javascript:
  $.get('/api/v1/categories.json', function(resultArray, status) {
    root = {
      'name': '',
      'visible': true,
      'children': resultArray
    };

    var computeMaxTextSize = function(data, fontSize, fontName){
      var maxH = 0, maxW = 0;

      var div = document.createElement('div');
      document.body.appendChild(div);
      $(div).css({
        position: 'absolute',
        left: -1000,
        top: -1000,
        display: 'none',
        margin: 0,
        padding: 0
      });

      $(div).css("font", fontSize + 'px '+fontName);

      data.forEach(function(d) {
          $(div).html(d);
          maxH = Math.max(maxH, $(div).outerHeight());
          maxW = Math.max(maxW, $(div).outerWidth());
      });

      $(div).remove();
      return {maxH: maxH, maxW: maxW};
    };

    var allStrings = [[]];
    var childStrings = function(level, n) {
        var a = allStrings[level];
        a.push(n.name);

        if(n.children && n.children.length > 0) {
            if(!allStrings[level+1]) {
                allStrings[level+1] = [];
            }
            n.children.forEach(function(d) {
                childStrings(level + 1, d);
            });
        }
    };
    childStrings(0, root);

    var maxLevelSizes = [];
    allStrings.forEach(function(d, i) {
        maxLevelSizes.push(computeMaxTextSize(allStrings[i], '10', 'sans-serif'));
    });
    var padding = 25; // Width of the blue circle plus some spacing
    var totalRadius = d3.sum(maxLevelSizes, function(d) { return d.maxW + padding});

    var diameter = totalRadius * 2; //960;

    var tree = d3.layout.tree()
        .size([360, totalRadius])
        .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

    var diagonal = d3.svg.diagonal.radial()
        .projection(function(d,i) { return [d.y, d.x / 180 * Math.PI]; });

    var svg = d3.select("#category-mindmap").append("svg")
        .attr("width", diameter)
        .attr("height", diameter - 150)
      .append("g")
        .attr("transform", "translate(" + (diameter / 2 - 150) + "," + (diameter / 2 - 150) + ")");

    var nodes = tree.nodes(root);

    // Compute cummulative sums - these will be the ring radii
    var newDepths = maxLevelSizes.reduce(function(prev, curr, index) {
        prev.push(prev[index] + curr.maxW + padding);
        return prev;
    },[0]);

    // Assign new radius based on depth
    nodes.forEach(function(d) {
        d.y = newDepths[d.depth];
    });

    var links = tree.links(nodes);

    var link = svg.selectAll(".link")
          .data(links)
        .enter().append("path")
          .attr("class", "link")
          .attr("d", diagonal);

    var node = svg.selectAll(".node")
          .data(nodes)
        .enter().append("g")
          .attr("class", "node")
          .attr("transform", function(d) {
              return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })

    node.append("circle")
          .attr("r", 4.5)
          .attr("class", function(d) { return d.visible ? 'visible' : 'not-visible' });

    node.append("text")
          .attr("dy", ".31em")
          .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
          .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
          .text(function(d) { return d.name; });

    d3.select(self.frameElement).style("height", diameter - 150 + "px");
  });
