coffee:
  $.widget 'backend.filteringSelect',
    options:
      createQuery: (query) ->
        return { query: query }
      minLength: 0
      searchDelay: 200
      remote_source: null
      source: null
      xhr: false

    _create: ->
      self = @
      select = @element.hide()
      selected = select.children(":selected")
      value = if selected.val() then selected.text() else ""

      if (@options.xhr)
        @options.source = @options.remote_source
      else
        @options.source = select.children("option").map( ->
          return { label: $(@).text(), value: @value }
        ).toArray()

      filtering_select = $('<div class="input-group filtering-select col-sm-4" style="float:left"></div>')
      input = @input = $('<input type="text">')
        .val(value)
        .addClass("form-control backend-filtering-select-input")
        .attr('style', select.attr('style'))
        .show()
        .autocomplete(
          delay: @options.searchDelay
          minLength: @options.minLength
          source: @_getSourceFunction(@options.source)
          select: (event, ui) ->
            option = $('<option></option>').attr('value', ui.item.id).attr('selected', 'selected').text(ui.item.value)
            select.html(option)
            select.trigger("change", ui.item.id)
            self._trigger("selected", event,
              item: option
            )
            $(self.element.parents('.controls')[0]).find('.update').removeClass('disabled')

          change: (event, ui) ->
            if (!ui.item)
              matcher = new RegExp("^" + $.ui.autocomplete.escapeRegex($(@).val()) + "$", "i")
              valid = false
              select.children("option").each( ->
                if ($(@).text().match(matcher))
                  @selected = valid = true
                  return false
              )
              if (!valid || $(@).val() == '')
                # remove invalid value, as it didn't match anything
                $(@).val(null)
                select.html($('<option value="" selected="selected"></option>'))
                input.data("ui-autocomplete").term = ""
                $(self.element.parents('.controls')[0]).find('.update').addClass('disabled')
                return false
        )
        .keyup( ->
          # Clear select options and trigger change if selected item is deleted
          if ($(@).val().length == 0)
            select.html($('<option value="" selected="selected"></option>'))
            select.trigger("change")
        )

      if(select.attr('placeholder'))
        input.attr('placeholder', select.attr('placeholder'))

      input.data("ui-autocomplete")._renderItem = (ul, item) ->
        return $("<li></li>")
          .data("ui-autocomplete-item", item)
          .append( $( "<a></a>" ).html( item.html || item.id ) )
          .appendTo(ul)

      button = @button = $('<span class="input-group-btn"><label class="btn btn-info dropdown-toggle" data-toggle="dropdown" aria-expanded="false" title="Show All Items" role="button"><span class="caret"></span><span class="ui-button-text">&nbsp</span></label></span>')
        .click ->
          # close if already visible
          if (input.autocomplete("widget").is(":visible"))
            input.autocomplete("close")
            return

          # pass empty string as value to search for, displaying all results
          input.autocomplete("search", "")
          input.focus()

      filtering_select.append(input).append(button).insertAfter(select)

    _getResultSet: (request, data, xhr) ->
      matcher = new RegExp($.ui.autocomplete.escapeRegex(request.term), "i")
      highlighter = (label, word) ->
        if (word.length > 0)
          return $.map(label.split(word), (el, i) ->
            return $('<span></span>').text(el).html()
          ).join($('<strong></strong>').text(word)[0].outerHTML)
        else
          return $('<span></span>').text(label).html()

      return $.map data, (el, i) ->
        # match regexp only for local requests, remote ones are already filtered, and label may not contain filtered term.
        if ((el.id || el.value) && (xhr || matcher.test(el.label)))
          return {
            html: highlighter(el.label || el.id, request.term),
            value: el.label || el.id,
            id: el.id || el.value
          }

    _getSourceFunction: (source) ->

      self = @
      requestIndex = 0

      if $.isArray(source)
        return (request, response) ->
          response(self._getResultSet(request, source, false))

      else if typeof source is "string"
        return (request, response) ->
          if (@xhr)
            @xhr.abort()

          @xhr = $.ajax(
            url: source
            data: self.options.createQuery(request.term)
            dataType: "json"
            autocompleteRequest: ++requestIndex
            success: (data, status) ->
              if (@autocompleteRequest is requestIndex)
                response(self._getResultSet(request, data, true))

            error: ->
              if (@autocompleteRequest is requestIndex)
                response([])
          )

      else
        return source

    destroy: ->
      @input.remove()
      @button.remove()
      @element.show()
      $.Widget.prototype.destroy.call(@)
  
  $ ->
    $('.filtering-select-field').each (index, select) ->
      $select = $(select)
      $select.filteringSelect($select.data('options'))


= form.input_field field_name, collection: collection, 
                               data: { options: js_data },
                               class: 'filtering-select-field form-control'
/, { selected: selected_id, include_blank: true }, field.html_attributes.reverse_merge({ data: { filteringselect: true, options: js_data.to_json }, placeholder: 'Suche' })
