coffee:
    $.widget 'backend.filteringMultiselect',
      _cache: {}
      options:
        createQuery: (query) ->
          return { query: query }
        sortable: false
        removable: true
        regional:
          up: "Up"
          down: "Down"
          add: "Add"
          chooseAll: "Choose all"
          chosen: "Chosen records"
          clearAll: "Clear all"
          remove: "Remove"
        searchDelay: 400
        remote_source: null
        xhr: false

      _create: ->
        @_cache = {}
        @_build()
        @_buildCache()
        @_bindEvents()

      _build: ->
        @wrapper = $('<div class="be-multiselect">')

        @wrapper.insertAfter(@element)

        @header = $('<div class="be-multiselect-header ui-helper-clearfix">')

        @filter = $('<input type="search" placeholder="' + @options.regional.search + '" class="form-control be-multiselect-search"/>')

        @header.append(@filter)

        @wrapper.append(@header)

        @columns =
          left: $('<div class="be-multiselect-column be-multiselect-left">')
          center: $('<div class="be-multiselect-column be-multiselect-center">')
          right: $('<div class="be-multiselect-column be-multiselect-right">')

        for i of @columns
          if @columns.hasOwnProperty(i)
            @wrapper.append(@columns[i])

        @collection = $('<select multiple="multiple"></select>')

        @collection.addClass("form-control be-multiselect-collection")

        @addAll = $('<a href="#" class="be-multiselect-item-add-all"><span class="ui-icon ui-icon-circle-triangle-e"></span>' + @options.regional.chooseAll + '</a>')

        @columns.left.html(@collection).append(@addAll)

        @collection.wrap('<div class="wrapper"/>')


        @add = $('<a href="#" class="ui-icon ui-icon-circle-triangle-e be-multiselect-item-add">' + @options.regional.add + '</a>')
        @columns.center.append(@add)

        if (@options.removable)
          @remove = $('<a href="#" class="ui-icon ui-icon-circle-triangle-w be-multiselect-item-remove">' + @options.regional.remove + '</a>')
          @columns.center.append(@remove)

        if (@options.sortable)
          @up = $('<a href="#" class="ui-icon ui-icon-circle-triangle-n be-multiselect-item-up">' + @options.regional.up + '</a>')
          @down = $('<a href="#" class="ui-icon ui-icon-circle-triangle-s be-multiselect-item-down">' + @options.regional.down + '</a>')
          @columns.center.append(@up).append(@down)

        @selection = $('<select class="form-control be-multiselect-selection" multiple="multiple"></select>')
        @columns.right.append(@selection)


        if (@options.removable)
          @removeAll = $('<a href="#" class="be-multiselect-item-remove-all"><span class="ui-icon ui-icon-circle-triangle-w"></span>' + @options.regional.clearAll + '</a>')
          @columns.right.append(@removeAll)

        @selection.wrap('<div class="wrapper"/>')

        @element.css({display: "none"})

        @tooManyObjectsPlaceholder = $('<option disabled="disabled" />').text("too_many_objects")
        @noObjectsPlaceholder = $('<option disabled="disabled" />').text("no_objects")

        if (@options.xhr)
          @collection.append(@tooManyObjectsPlaceholder)


      _bindEvents: ->
        widget = this

        # Add all to selection
        @addAll.click (e) ->
          widget._select($('option', widget.collection))
          e.preventDefault()
          widget.selection.trigger('change')

        # Add to selection
        @add.click (e) ->
          widget._select($(':selected', widget.collection))

          e.preventDefault()
          widget.selection.trigger('change')

        if (@options.removable)
          # Remove all from selection
          @removeAll.click (e) ->
            widget._deSelect($('option', widget.selection))
            e.preventDefault()
            widget.selection.trigger('change')

          # Remove from selection
          @remove.click (e) ->
            widget._deSelect($(':selected', widget.selection))
            e.preventDefault()
            widget.selection.trigger('change')

        timeout = null
        if(@options.sortable)
          # Move selection up
          @up.click (e) ->
            widget._move('up', $(':selected', widget.selection))
            e.preventDefault()

          # Move selection down
          @down.click (e) ->
            widget._move('down', $(':selected', widget.selection))
            e.preventDefault()

        # Typing to the filter
        @filter.bind 'keyup click', (e) ->
          if timeout then clearTimeout(timeout)
          timeout = setTimeout( ->
              widget._queryFilter(widget.filter.val())
            , widget.options.searchDelay
          )

      _queryFilter: (val) ->
        widget = this
        widget._query val, (matches) ->
          filtered = []
          for i of matches
            if matches.hasOwnProperty(i) && !widget.selected(matches[i].id)
              filtered.push(i)

          if (filtered.length > 0)
            widget.collection.html('')
            for i of filtered
              widget.collection.append(
                $('<option></option>').attr('value', matches[filtered[i]].id).attr('title', matches[filtered[i]].label).text(matches[filtered[i]].label)
              )

          else
            widget.collection.html(widget.noObjectsPlaceholder)

      ###
       * Cache key is stored in the format `o_<option value>` to avoid JS
       * engine coercing string keys to int keys, and thereby preserving
       * the insertion order. The value for each key is in turn an object
       * that stores the option tag's HTML text and the value. Example:
       * cache = {
       *    'o_271': { id: 271, value: 'CartItem #271'},
       *    'o_270': { id: 270, value: 'CartItem #270'}
       * }
      ###
      _buildCache: (options) ->
        widget = this

        @element.find("option").each (i, option) ->
          if (option.selected)
            widget._cache['o_' + option.value] = {id: option.value, value: option.innerHTML}
            $(option).clone().appendTo(widget.selection).attr("selected", false).attr("title", $(option).text())
          else
            widget._cache['o_' + option.value] = {id: option.value, value: option.innerHTML}
            $(option).clone().appendTo(widget.collection).attr("selected", false).attr("title", $(option).text())

      _deSelect: (options) ->
        widget = this
        options.each (i, option) ->
          widget.element.find('option[value="' + option.value + '"]').removeAttr("selected")

        $(options).appendTo(@collection).attr('selected', false)

      _query: (query, success) ->
        matches = []

        if query is ""
          if (!@options.xhr)
            for i of @_cache
              if (@_cache.hasOwnProperty(i))
                option = @_cache[i]
                matches.push({id: option.id, label: option.value})
            success.apply(this, [matches])
          else
            @collection.html(@tooManyObjectsPlaceholder)

        else
          if (@options.xhr)

            $.ajax(
              beforeSend: (xhr) ->
                xhr.setRequestHeader("Accept", "application/json")
              url: @options.remote_source
              data: @options.createQuery(query)
              success: success
            )

          else

            query = new RegExp(query + '.*', 'i')

            for i of @_cache
              if (@_cache.hasOwnProperty(i) && query.test(@_cache[i]['value']))
                option = @_cache[i]
                matches.push({id: option.id, label: option.value})

            success.apply(this, [matches])

      _select: (options) ->
        widget = this
        options.each (i, option) ->
          el = widget.element.find('option[value="' + option.value + '"]')
          if (el.length)
            el.attr("selected", "selected")
          else
            widget.element.append($('<option></option>').attr('value', option.value).attr('selected', "selected"))

        $(options).appendTo(@selection).attr('selected', false)

      _move: (direction, options) ->
        widget = this
        if (direction is 'up')
          options.each (i, option) ->
            prev = $(option).prev()
            if (prev.length > 0)
              el = widget.element.find('option[value="' + option.value + '"]')
              el_prev = widget.element.find('option[value="' + prev[0].value + '"]')
              el_prev.before(el)
              prev.before($(option))
        else
          $.fn.reverse = [].reverse # needed to lower last items first
          options.reverse().each (i, option) ->
            next = $(option).next()
            if (next.length > 0)
              el = widget.element.find('option[value="' + option.value + '"]')
              el_next = widget.element.find('option[value="' + next[0].value + '"]')
              el_next.after(el)
              next.after($(option))

      selected: (value) ->
        @element.find('option[value="' + value + '"]').attr("selected")

      destroy: ->
        @wrapper.remove()
        @element.css({display: "inline"})
        $.Widget.prototype.destroy.apply(this, arguments)

  $ ->
    $('.filtering-multiselect-field').each (index, select) ->
      $select = $(select)
      $select.filteringMultiselect($select.data('options'))

/ :ruby
/   related_id = params[:associations] && params[:associations][field.name.to_s]
/   config = field.associated_model_config
/   source_abstract_model = RailsAdmin.config(form.object.class).abstract_model
/ 
/   if form.object.new_record? && related_id.present? && related_id != 'new'
/     selected = [config.abstract_model.get(related_id)]
/   else
/     selected = form.object.send(field.name)
/   end
/   selected_ids = selected.map{|s| s.send(field.associated_primary_key)}
/ 
/   current_action = params[:action].in?(['create', 'new']) ? 'create' : 'update'
/ 
/   xhr = !field.associated_collection_cache_all
/ 
/   collection = if xhr
/     selected.map { |o| [o.send(field.associated_object_label_method), o.send(field.associated_primary_key)] }
/   else
/     i = 0
/     controller.list_entries(config, :index, field.associated_collection_scope, false).map { |o| [o.send(field.associated_object_label_method), o.send(field.associated_primary_key)] }.sort_by {|a| [selected_ids.index(a[1]) || selected_ids.size, i+=1] }
/   end
/ 
/   js_data = {
/     xhr: xhr,
/     :'edit-url' => (authorized?(:edit, config.abstract_model) ? edit_path(model_name: config.abstract_model.to_param, id: '__ID__') : ''),
/     remote_source: index_path(config.abstract_model, source_object_id: form.object.id, source_abstract_model: source_abstract_model.to_param, associated_collection: field.name, current_action: current_action, compact: true),
/     sortable: !!field.orderable,
/     removable: !!field.removable,
/     cacheAll: !!field.associated_collection_cache_all,
/     regional: {
/       chooseAll: t("admin.misc.chose_all"),
/       chosen: t("admin.misc.chosen", name: config.label_plural),
/       clearAll: t("admin.misc.clear_all"),
/       search: t("admin.misc.search"),
/       up: t("admin.misc.up"),
/       down: t("admin.misc.down")
/     }
/   }
input name=field_name type="hidden" value=""

/ - selected_ids = (hdv = field.form_default_value).nil? ? selected_ids : hdv
= form.input_field field_name, collection: collection, 
                               multiple: true,
                               data: { options: js_data },
                               class: 'filtering-multiselect-field form-control'
